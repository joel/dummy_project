name: Docker Cached Image

on: [push]

jobs:

  image-build-and-cache:

    runs-on: ubuntu-latest

    outputs:
      branch: ${{ steps.branch-commits.outputs.branch }}
      sha: ${{ steps.branch-commits.outputs.sha_short }}

    steps:
      - name: Check Out Code
        uses: actions/checkout@v2

      - name: Get Current Branch and Commit
        id: branch-commits
        shell: bash
        run: |
          echo "##[set-output name=branch;]$(echo ${GITHUB_REF#refs/heads/})"
          echo "::set-output name=sha_short::$(git rev-parse --short HEAD)"

      - name: Show Current Branch and Commit
        run: |
          echo "Branch: ${{ steps.branch-commits.outputs.branch }}"
          echo "Sha: ${{ steps.branch-commits.outputs.sha_short }}"

      - name: Create Cache Registry
        id: cache-docker-images-code
        uses: actions/cache@v2
        with:
          path: ${{ env.IMAGE_CACHE_DIR }}/code
          key: ${{ runner.os }}-docker-images-${{ steps.branch-commits.outputs.sha_short }}

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v1

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1

      - name: Build Docker Image from Source Code
        if: steps.cache-docker-images-code.outputs.cache-hit != 'true'
        run: |
          docker build \
            . \
            --build-arg ARG_RUBY_VERSION=${RUBY_VERSION} \
            --tag ${{ env.SERVICE_NAME }}/app-ci:latest \
            -f dockerfiles/Dockerfile-ci
          mkdir -p ${{ env.IMAGE_CACHE_DIR }}/code
          docker save --output ${{ env.IMAGE_CACHE_DIR }}/code/image-app.tar ${{ env.SERVICE_NAME }}/app-ci:latest

      - name: Create Cache Registry For Utilities
        id: cache-docker-image-utilities
        uses: actions/cache@v2
        with:
          path: ${{ env.IMAGE_CACHE_DIR }}/utilities
          key: ${{ runner.os }}-docker-images-${{ env.COMPOSE_WAIT_VER }}-${{ hashFiles('dockerfiles/Dockerfile-wait') }}

      - name: Build Wait Image
        if: steps.cache-docker-image-utilities.outputs.cache-hit != 'true'
        run: |
          docker build . \
            --build-arg ARG_COMPOSE_WAIT_VER=${{ env.COMPOSE_WAIT_VER }} \
            --tag ${{ env.SERVICE_NAME }}/wait:${{ env.COMPOSE_WAIT_VER }} \
            -f dockerfiles/Dockerfile-wait
          mkdir -p ${{ env.IMAGE_CACHE_DIR }}/utilities
          docker save --output ${{ env.IMAGE_CACHE_DIR }}/utilities/image-wait.tar ${{ env.SERVICE_NAME }}/wait:${{ env.COMPOSE_WAIT_VER }}

      - name: Check Cache
        run: |
          ls -l ${{ env.IMAGE_CACHE_DIR }}/code
          ls -l ${{ env.IMAGE_CACHE_DIR }}/utilities

  test-channels:

    needs: image-build-and-cache

    uses: joel/reusable-workflow/.github/workflows/reusable-workflow.yml@main
    with:
      run-test: "bin/rake test:channels"
      image-build-and-cache-outputs-sha: ${{ needs.image-build-and-cache.outputs.sha }}

  test-controllers:

    needs: image-build-and-cache

    uses: joel/reusable-workflow/.github/workflows/reusable-workflow.yml@main
    with:
      run-test: "bin/rake test:controllers"
      image-build-and-cache-outputs-sha: ${{ needs.image-build-and-cache.outputs.sha }}

  test-models:

    needs: image-build-and-cache

    uses: joel/reusable-workflow/.github/workflows/reusable-workflow.yml@main
    with:
      run-test: "bin/rake test:models"
      image-build-and-cache-outputs-sha: ${{ needs.image-build-and-cache.outputs.sha }}

  test-helpers:

    needs: image-build-and-cache

    uses: joel/reusable-workflow/.github/workflows/reusable-workflow.yml@main
    with:
      run-test: "bin/rake test:helpers"
      image-build-and-cache-outputs-sha: ${{ needs.image-build-and-cache.outputs.sha }}

  test-mailers:

    needs: image-build-and-cache

    uses: joel/reusable-workflow/.github/workflows/reusable-workflow.yml@main
    with:
      run-test: "bin/rake test:mailers"
      image-build-and-cache-outputs-sha: ${{ needs.image-build-and-cache.outputs.sha }}